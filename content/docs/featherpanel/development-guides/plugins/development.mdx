---
id: development
title: Plugin Development
description: Creating plugins, file structure, and development workflow
---

# Plugin Development

This guide covers the complete plugin development workflow, from creation to deployment.

## Development Workflow

### 1. Planning Your Plugin

Before creating a plugin, consider:

-   **Purpose**: What problem does your plugin solve?
-   **Functionality**: What features will it provide?
-   **Dependencies**: What does it need to work?
-   **Integration**: How will it integrate with FeatherPanel?
-   **Users**: Who will use it and how?

### 2. Setting Up Development Environment

1. **Enable Developer Mode** in FeatherPanel settings
2. **Access Plugin Manager** in the admin interface
3. **Set up your development tools** (IDE, version control, etc.)

### 3. Creating Your Plugin

#### Method 1: Using Plugin Manager (Recommended)

1. Navigate to **Admin â†’ Plugin Manager**
2. Click **"Create New Plugin"**
3. Fill in plugin details:
    - **Identifier**: `my_awesome_plugin`
    - **Name**: `My Awesome Plugin`
    - **Description**: `Adds awesome features to FeatherPanel`
    - **Version**: `1.0.0`
    - **Author**: `Your Name`
4. Configure dependencies and required configs
5. Click **"Create Plugin"**

The system will generate:

-   Complete directory structure
-   Main plugin class with boilerplate code
-   Example files (migrations, cron, commands)
-   Frontend assets and sidebar configuration
-   Configuration files

#### Method 2: Manual Creation

1. Create plugin directory: `storage/addons/my_plugin/`
2. Create `conf.yml` with plugin configuration
3. Create main plugin class: `MyPlugin.php`
4. Implement required interfaces
5. Add additional files as needed

## Plugin File Structure

```
storage/addons/my_plugin/
â”œâ”€â”€ conf.yml                    # Plugin configuration
â”œâ”€â”€ MyPlugin.php               # Main plugin class
â”œâ”€â”€ README.md                  # Plugin documentation
â”œâ”€â”€ Migrations/                # Database migrations
â”‚   â”œâ”€â”€ 2024-01-15-14.30-create-logs.sql
â”‚   â”œâ”€â”€ 2024-01-15-15.00-add-indexes.sql
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Cron/                      # Scheduled tasks
â”‚   â”œâ”€â”€ CleanupCron.php
â”‚   â”œâ”€â”€ BackupCron.php
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Commands/                  # CLI commands
â”‚   â”œâ”€â”€ MyCommand.php
â”‚   â”œâ”€â”€ StatusCommand.php
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Events/                    # Event handlers
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â””â”€â”€ AppReadyEvent.php
â”‚   â”œâ”€â”€ User/
â”‚   â”‚   â””â”€â”€ UserLoginEvent.php
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Frontend/                  # Frontend assets
â”‚   â”œâ”€â”€ index.js              # JavaScript
â”‚   â”œâ”€â”€ index.css             # Stylesheets
â”‚   â”œâ”€â”€ sidebar.json          # Sidebar configuration
â”‚   â”œâ”€â”€ Components/           # Plugin HTML pages (optional)
â”‚   â”‚   â”œâ”€â”€ main-page.html
â”‚   â”‚   â””â”€â”€ settings.html
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Public/                    # Public assets
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ logo.png
â”‚   â”œâ”€â”€ styles/
â”‚   â”‚   â””â”€â”€ plugin.css
â”‚   â””â”€â”€ .gitkeep
â”œâ”€â”€ Controllers/               # API controllers (optional)
â”‚   â”œâ”€â”€ ApiController.php
â”‚   â””â”€â”€ .gitkeep
â””â”€â”€ Services/                  # Business logic (optional)
    â”œâ”€â”€ MyService.php
    â””â”€â”€ .gitkeep
```

## Main Plugin Class

### Basic Structure

```php
<?php

namespace App\Addons\my_plugin;

use App\Plugins\Events\Events\AppEvent;
use App\Plugins\AppPlugin;
use App\Plugins\PluginEvents;
use App\Addons\my_plugin\Events\App\AppReadyEvent;

class MyPlugin implements AppPlugin
{
    /**
     * Process plugin events
     */
    public static function processEvents(PluginEvents $event): void
    {
        // Hook into router ready event
        $event->on(AppEvent::onRouterReady(), function ($router) {
            new AppReadyEvent($router);
        });

        // Add more event listeners
        $event->on('user.login', function ($user) {
            // Handle user login
            self::handleUserLogin($user);
        });

        $event->on('server.created', function ($server) {
            // Handle server creation
            self::handleServerCreation($server);
        });
    }

    /**
     * Plugin installation
     */
    public static function pluginInstall(): void
    {
        // Create necessary tables, directories, etc.
        self::createDirectories();
        self::initializeSettings();
    }

    /**
     * Plugin uninstallation
     */
    public static function pluginUninstall(): void
    {
        // Clean up tables, files, etc.
        self::cleanupData();
        self::removeDirectories();
    }

    /**
     * Handle user login event
     */
    private static function handleUserLogin(array $user): void
    {
        // Log user login
        error_log("User {$user['email']} logged in");

        // Update user activity
        self::updateUserActivity($user['id']);
    }

    /**
     * Handle server creation event
     */
    private static function handleServerCreation(array $server): void
    {
        // Initialize server data
        self::initializeServerData($server['id']);

        // Send notification
        self::sendServerCreatedNotification($server);
    }

    /**
     * Create plugin directories
     */
    private static function createDirectories(): void
    {
        $directories = [
            'logs',
            'cache',
            'uploads'
        ];

        foreach ($directories as $dir) {
            $path = APP_ADDONS_DIR . '/my_plugin/' . $dir;
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
            }
        }
    }

    /**
     * Initialize plugin settings
     */
    private static function initializeSettings(): void
    {
        use App\Plugins\PluginSettings;

        // Set default settings
        PluginSettings::setSetting('my_plugin', 'enabled', 'true');
        PluginSettings::setSetting('my_plugin', 'version', '1.0.0');
    }

    /**
     * Clean up plugin data
     */
    private static function cleanupData(): void
    {
        // Remove plugin-specific data
        // This is called during uninstallation
    }

    /**
     * Remove plugin directories
     */
    private static function removeDirectories(): void
    {
        // Remove plugin-specific directories
        // This is called during uninstallation
    }
}
```

## Database Migrations

### Creating Migrations

Create SQL files in the `Migrations/` directory with timestamp naming:

```sql
-- 2024-01-15-14.30-create-logs.sql
CREATE TABLE IF NOT EXISTS `featherpanel_my_plugin_logs` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `user_id` INT NOT NULL,
    `action` VARCHAR(50) NOT NULL,
    `message` TEXT NOT NULL,
    `level` VARCHAR(20) DEFAULT 'info',
    `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    INDEX `idx_user_id` (`user_id`),
    INDEX `idx_created_at` (`created_at`)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_general_ci;

-- Insert example data
INSERT IGNORE INTO `featherpanel_my_plugin_logs` (`user_id`, `action`, `message`, `level`)
VALUES (1, 'install', 'Plugin my_plugin initialized successfully', 'info');
```

### Migration Best Practices

-   Use descriptive filenames with timestamps
-   Include `IF NOT EXISTS` for safety
-   Add proper indexes for performance
-   Use plugin-specific table prefixes
-   Include rollback instructions in comments

## Scheduled Tasks (Cron Jobs)

### Creating Cron Jobs

```php
<?php

namespace App\Addons\my_plugin\Cron;

use App\Cron\Cron;
use App\Cron\TimeTask;
use App\Chat\TimedTask;

class CleanupCron implements TimeTask
{
    public function run()
    {
        $cron = new Cron('my-plugin-cleanup', '1D'); // Run daily
        try {
            $cron->runIfDue(function () {
                // Cleanup old logs
                $this->cleanupOldLogs();

                // Cleanup temporary files
                $this->cleanupTempFiles();

                TimedTask::markRun('my-plugin-cleanup', true, 'Cleanup completed');
            });
        } catch (\Exception $e) {
            $app = \App\App::getInstance(false, true);
            $app->getLogger()->error('Failed to run cleanup cron: ' . $e->getMessage());
            TimedTask::markRun('my-plugin-cleanup', false, $e->getMessage());
        }
    }

    private function cleanupOldLogs(): void
    {
        // Delete logs older than 30 days
        $db = new \App\Chat\Database(
            $_ENV['DATABASE_HOST'] ?? '127.0.0.1',
            $_ENV['DATABASE_DATABASE'] ?? '',
            $_ENV['DATABASE_USER'] ?? '',
            $_ENV['DATABASE_PASSWORD'] ?? '',
            (int) ($_ENV['DATABASE_PORT'] ?? 3306)
        );

        $pdo = $db->getPdo();
        $stmt = $pdo->prepare("
            DELETE FROM featherpanel_my_plugin_logs
            WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY)
        ");
        $stmt->execute();
    }

    private function cleanupTempFiles(): void
    {
        $tempDir = APP_ADDONS_DIR . '/my_plugin/temp/';
        if (is_dir($tempDir)) {
            $files = glob($tempDir . '*');
            foreach ($files as $file) {
                if (is_file($file) && filemtime($file) < time() - 3600) { // 1 hour old
                    unlink($file);
                }
            }
        }
    }
}
```

### Cron Schedule Formats

-   `1m` - Every minute
-   `5m` - Every 5 minutes
-   `1H` - Every hour
-   `6H` - Every 6 hours
-   `1D` - Every day
-   `1W` - Every week

## CLI Commands

### Creating CLI Commands

```php
<?php

namespace App\Addons\my_plugin\Commands;

use App\Cli\App;
use App\Cli\CommandBuilder;

class MyCommand implements CommandBuilder
{
    public static function execute(array $args): void
    {
        $app = App::getInstance();

        if (empty($args)) {
            $app->send("&aMy Plugin Command");
            $app->send("&7Usage: php cli.php my_plugin [subcommand]");
            $app->send("&7Available subcommands: status, cleanup, test");
            return;
        }

        $subcommand = $args[0];

        switch ($subcommand) {
            case 'status':
                self::showStatus($app);
                break;
            case 'cleanup':
                self::runCleanup($app);
                break;
            case 'test':
                self::runTest($app);
                break;
            default:
                $app->send("&cUnknown subcommand: {$subcommand}");
                break;
        }
    }

    public static function getDescription(): string
    {
        return "Execute My Plugin functionality via CLI";
    }

    public static function getSubCommands(): array
    {
        return [
            'status' => 'Show plugin status and statistics',
            'cleanup' => 'Run cleanup tasks manually',
            'test' => 'Run plugin tests'
        ];
    }

    private static function showStatus(App $app): void
    {
        $app->send("&aMy Plugin Status:");
        $app->send("&7Version: 1.0.0");
        $app->send("&7Status: Active");

        // Get statistics
        $db = new \App\Chat\Database(
            $_ENV['DATABASE_HOST'] ?? '127.0.0.1',
            $_ENV['DATABASE_DATABASE'] ?? '',
            $_ENV['DATABASE_USER'] ?? '',
            $_ENV['DATABASE_PASSWORD'] ?? '',
            (int) ($_ENV['DATABASE_PORT'] ?? 3306)
        );

        $pdo = $db->getPdo();
        $stmt = $pdo->query("SELECT COUNT(*) FROM featherpanel_my_plugin_logs");
        $logCount = $stmt->fetchColumn();

        $app->send("&7Log entries: {$logCount}");
    }

    private static function runCleanup(App $app): void
    {
        $app->send("&aRunning cleanup tasks...");

        // Run cleanup logic
        $cleanupCron = new \App\Addons\my_plugin\Cron\CleanupCron();
        $cleanupCron->run();

        $app->send("&aCleanup completed!");
    }

    private static function runTest(App $app): void
    {
        $app->send("&aRunning plugin tests...");

        // Run tests
        $tests = [
            'Database connection' => self::testDatabase(),
            'Settings access' => self::testSettings(),
            'File permissions' => self::testFilePermissions()
        ];

        foreach ($tests as $test => $result) {
            $status = $result ? '&aPASS' : '&cFAIL';
            $app->send("&7{$test}: {$status}");
        }
    }

    private static function testDatabase(): bool
    {
        try {
            $db = new \App\Chat\Database(
                $_ENV['DATABASE_HOST'] ?? '127.0.0.1',
                $_ENV['DATABASE_DATABASE'] ?? '',
                $_ENV['DATABASE_USER'] ?? '',
                $_ENV['DATABASE_PASSWORD'] ?? '',
                (int) ($_ENV['DATABASE_PORT'] ?? 3306)
            );
            $pdo = $db->getPdo();
            $pdo->query("SELECT 1");
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }

    private static function testSettings(): bool
    {
        try {
            use App\Plugins\PluginSettings;
            PluginSettings::getSetting('my_plugin', 'enabled');
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }

    private static function testFilePermissions(): bool
    {
        $pluginDir = APP_ADDONS_DIR . '/my_plugin/';
        return is_dir($pluginDir) && is_writable($pluginDir);
    }
}
```

## Frontend Integration

FeatherPanel plugins can integrate with the frontend in two ways:

1. **Plugin Pages** - Standalone pages with custom routes (see [Plugin Pages](#plugin-pages) below)
2. **Plugin Widgets** - Embedded content on existing pages (see [Plugin Widgets](./plugins-widgets))

### JavaScript Integration

```javascript
// Frontend/index.js
class MyPlugin {
    constructor() {
        this.api = null;
        this.ui = new MyPluginUI();
    }

    async init(api) {
        this.api = api;
        console.log('My Plugin initialized!');

        // Initialize UI components
        this.ui.init();
    }

    showDashboard() {
        console.log('Opening My Plugin Dashboard...');
        this.ui.showModal('dashboard', 'My Plugin Dashboard', this.getDashboardContent());
    }

    showSettings() {
        console.log('Opening My Plugin Settings...');
        this.ui.showModal('settings', 'My Plugin Settings', this.getSettingsContent());
    }

    getDashboardContent() {
        return `
            <div class="my-plugin-grid">
                <div class="my-plugin-card">
                    <h3>ğŸ“Š Plugin Status</h3>
                    <p>Status: <span class="my-plugin-status active">Active</span></p>
                    <p>Version: 1.0.0</p>
                </div>
                <div class="my-plugin-card">
                    <h3>ğŸ“ˆ Statistics</h3>
                    <p>Total logs: <strong>1,234</strong></p>
                    <p>Active users: <strong>89</strong></p>
                </div>
            </div>
        `;
    }

    getSettingsContent() {
        return `
            <div class="my-plugin-settings">
                <div class="setting-group">
                    <label>
                        <input type="checkbox" checked> Enable logging
                    </label>
                </div>
                <div class="setting-group">
                    <label>
                        <input type="checkbox"> Debug mode
                    </label>
                </div>
            </div>
        `;
    }
}

// Initialize plugin
async function initMyPlugin() {
    const api = window.FeatherPanel.api;
    const plugin = new MyPlugin();
    await plugin.init(api);
    window.MyPlugin = plugin;
}

initMyPlugin();
```

### CSS Styling

```css
/* Frontend/index.css */
.my-plugin-container {
    padding: 20px;
    border-radius: 8px;
    background: #f8fafc;
    border: 1px solid #e2e8f0;
}

.my-plugin-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 16px;
}

.my-plugin-card {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 16px;
}

.my-plugin-card h3 {
    margin: 0 0 8px 0;
    font-size: 1rem;
    font-weight: 600;
    color: #111827;
}

.my-plugin-status {
    display: inline-block;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
}

.my-plugin-status.active {
    background: #d1fae5;
    color: #065f46;
}

.my-plugin-settings {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.setting-group {
    display: flex;
    align-items: center;
    gap: 8px;
}

.setting-group label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}
```

### Sidebar Configuration

The sidebar configuration file (`Frontend/sidebar.json`) allows plugins to add navigation items to different sections of FeatherPanel. Items can be organized into groups, use emoji icons, and support both JavaScript actions and HTML component pages.

#### Supported Sections

-   **`dashboard`** - Dashboard sidebar (user panel)
-   **`client`** - Client sidebar (alternative user panel section)
-   **`admin`** - Admin panel sidebar
-   **`server`** - Server sidebar (shown when viewing a server)

#### Complete Sidebar Configuration Example

```json
{
    "dashboard": {
        "/overview": {
            "name": "My Plugin Overview",
            "icon": "ğŸ“Š",
            "js": "if (window.MyPlugin) { window.MyPlugin.showDashboard(); }",
            "description": "View plugin overview and statistics",
            "category": "general",
            "showBadge": false
        }
    },
    "client": {
        "/client-feature": {
            "name": "Client Feature",
            "icon": "ğŸ¯",
            "component": "client-feature.html",
            "redirect": "/client-feature",
            "description": "Access client feature",
            "category": "client",
            "showBadge": true
        }
    },
    "admin": {
        "/settings": {
            "name": "My Plugin Settings",
            "icon": "âš™ï¸",
            "js": "if (window.MyPlugin) { window.MyPlugin.showSettings(); }",
            "description": "Configure plugin settings",
            "category": "admin",
            "permission": "admin.plugin.settings",
            "group": "Plugin Management",
            "showBadge": false
        },
        "/advanced": {
            "name": "Advanced Settings",
            "icon": "ğŸ”§",
            "component": "advanced-settings.html",
            "redirect": "/advanced",
            "description": "Advanced plugin configuration",
            "category": "admin",
            "permission": "admin.plugin.advanced",
            "group": "Plugin Management",
            "showBadge": false
        }
    },
    "server": {
        "/logs": {
            "name": "My Plugin Logs",
            "icon": "ğŸ“",
            "js": "if (window.MyPlugin) { window.MyPlugin.showLogs(); }",
            "description": "View plugin logs",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        },
        "/manager": {
            "name": "Plugin Manager",
            "icon": "ğŸ”",
            "component": "serverui.html",
            "redirect": "/manager",
            "description": "Manage plugin features",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        }
    }
}
```

#### Sidebar Item Properties

| Property          | Type    | Required       | Description                                                                                                                                                         |
| ----------------- | ------- | -------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`name`**        | string  | âœ… Yes         | Display name shown in the sidebar menu                                                                                                                              |
| **`icon`**        | string  | âœ… Yes         | Emoji icon displayed next to the menu item (e.g., "ğŸ“Š", "âš™ï¸", "ğŸ”")                                                                                                 |
| **`description`** | string  | âœ… Yes         | Tooltip text shown when hovering over the menu item                                                                                                                 |
| **`category`**    | string  | âœ… Yes         | Context category: `"dashboard"`, `"client"`, `"admin"`, or `"server"`                                                                                               |
| **`js`**          | string  | âš ï¸ Conditional | JavaScript code to execute when item is clicked (use with `js` OR `component`)                                                                                      |
| **`component`**   | string  | âš ï¸ Conditional | Path to HTML file in `Components/` directory (use with `component` OR `js`)                                                                                         |
| **`redirect`**    | string  | âŒ No          | URL path for navigation (recommended when using `component`)                                                                                                        |
| **`permission`**  | string  | âŒ No          | Required permission to access this item (e.g., `"admin.plugin.settings"`)                                                                                           |
| **`group`**       | string  | âŒ No          | Group name for organizing items. Items with the same group name will be grouped together with a separator (e.g., `"Minecraft Java Edition"`, `"Plugin Management"`) |
| **`showBadge`**   | boolean | âŒ No          | Show plugin name badge next to the item (default: `false`)                                                                                                          |

#### Using Groups for Organization

The `group` property allows you to organize sidebar items into logical groups. Items with the same group name will be visually grouped together with a separator:

```json
{
    "server": {
        "/java-edition": {
            "name": "Java Edition Manager",
            "icon": "â˜•",
            "component": "java-manager.html",
            "redirect": "/java-edition",
            "description": "Manage Java Edition servers",
            "category": "server",
            "group": "Minecraft Java Edition"
        },
        "/bedrock-edition": {
            "name": "Bedrock Edition Manager",
            "icon": "ğŸ®",
            "component": "bedrock-manager.html",
            "redirect": "/bedrock-edition",
            "description": "Manage Bedrock Edition servers",
            "category": "server",
            "group": "Minecraft Bedrock Edition"
        }
    }
}
```

This will create two separate groups in the sidebar:

-   **Minecraft Java Edition**
    -   â˜• Java Edition Manager
-   **Minecraft Bedrock Edition**
    -   ğŸ® Bedrock Edition Manager

#### Icon Support

Icons are displayed as emoji strings. Choose emojis that clearly represent the feature:

-   ğŸ“Š Charts/Statistics
-   âš™ï¸ Settings/Configuration
-   ğŸ” Search/Management
-   ğŸ“ Logs/Documentation
-   ğŸ® Games/Gaming
-   ğŸ“¦ Packages/Installations
-   ğŸ”§ Tools/Utilities
-   ğŸ¯ Targets/Goals
-   â˜• Java/Coffee (for Java-related features)

#### JavaScript vs Component Pages

You can use either `js` or `component` (but not both):

**JavaScript Actions (`js`):**

```json
{
    "/action": {
        "name": "Quick Action",
        "icon": "âš¡",
        "js": "if (window.MyPlugin) { window.MyPlugin.performAction(); }",
        "description": "Execute quick action",
        "category": "server"
    }
}
```

**Component Pages (`component`):**

```json
{
    "/page": {
        "name": "Plugin Page",
        "icon": "ğŸ“„",
        "component": "plugin-page.html",
        "redirect": "/page",
        "description": "View plugin page",
        "category": "server"
    }
}
```

When using `component`, always include `redirect` to ensure proper navigation.

## Plugin Pages

Plugins can create dedicated HTML pages that are loaded when users navigate to plugin routes. These pages are full HTML documents that can include complex interfaces, forms, and interactive components.

### Creating Plugin Pages

Plugin pages are HTML files stored in the `Frontend/Components/` directory. They are registered in `sidebar.json` using the `component` property instead of `js`.

#### File Structure

```
storage/addons/my_plugin/
â”œâ”€â”€ Frontend/
â”‚   â”œâ”€â”€ index.js              # Plugin JavaScript initialization
â”‚   â”œâ”€â”€ index.css             # Plugin styles
â”‚   â”œâ”€â”€ sidebar.json          # Sidebar configuration with page routes
â”‚   â””â”€â”€ Components/           # Plugin page components
â”‚       â”œâ”€â”€ main-page.html    # Main plugin page
â”‚       â”œâ”€â”€ settings.html     # Settings page
â”‚       â””â”€â”€ reports.html      # Reports page
```

### Registering Plugin Pages

Pages are registered in `Frontend/sidebar.json` using the `component` property. You can organize pages into groups and use various properties to customize their appearance and behavior:

```json
{
    "dashboard": {},
    "client": {},
    "admin": {
        "/settings": {
            "name": "Plugin Settings",
            "icon": "âš™ï¸",
            "component": "settings.html",
            "redirect": "/settings",
            "description": "Configure plugin settings",
            "category": "admin",
            "permission": "admin.plugin.settings",
            "group": "Plugin Management",
            "showBadge": false
        }
    },
    "server": {
        "/myplugin": {
            "name": "My Plugin",
            "icon": "ğŸ”",
            "component": "main-page.html",
            "redirect": "/myplugin",
            "description": "Access My Plugin interface",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        }
    }
}
```

> **Note:** See the [Sidebar Configuration](#sidebar-configuration) section above for complete details on all available properties.

### Creating HTML Components

Plugin pages can be created in two ways:

#### Method 1: Static HTML Pages

Simple HTML documents that can include:

-   **Full HTML structure** with `<head>` and `<body>` tags
-   **External libraries** (e.g., Tailwind CSS, Font Awesome)
-   **Inline CSS** and JavaScript
-   **Interactive forms** and UI components
-   **API calls** to backend endpoints

#### Method 2: Vite-Built Applications (Vue, React, etc.)

For more complex applications, you can use Vite to build Vue, React, or other framework-based applications. This allows you to use modern development tools, component libraries, and build processes.

**Requirements:**

-   Custom Vite configuration with specific settings
-   Router configured with hash history (for Vue Router)
-   Build output directory pointing to `Components/{name}/dist/`

#### Example Plugin Page

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>My Plugin Page</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
        <style>
            body {
                background: transparent;
                color: #fafafa;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                padding: 1.5rem;
            }

            .content-block {
                background: rgba(18, 19, 21, 0.8);
                backdrop-filter: blur(2px);
                border-radius: 0.75rem;
                padding: 1.5rem 2rem;
                border: 1px solid rgba(255, 255, 255, 0.07);
            }
        </style>
    </head>
    <body>
        <div class="content-block">
            <h1>My Plugin Page</h1>
            <p>This is a custom plugin page with full HTML structure.</p>
        </div>

        <script>
            // Extract server UUID from query string if needed
            function getServerUuidFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('serverUuid') || null;
            }

            // Make API calls to your plugin endpoints
            async function fetchPluginData() {
                const serverUuid = getServerUuidFromUrl();
                if (!serverUuid) return;

                try {
                    const response = await fetch(`/api/user/servers/${serverUuid}/addons/my_plugin/data`);
                    const result = await response.json();

                    if (result.success) {
                        // Update UI with data
                        console.log('Plugin data:', result.data);
                    }
                } catch (error) {
                    console.error('Failed to fetch data:', error);
                }
            }

            // Initialize on page load
            window.addEventListener('DOMContentLoaded', () => {
                fetchPluginData();
            });
        </script>
    </body>
</html>
```

### Multiple Pages

Plugins can register multiple pages across different contexts. Use the `group` property to organize related pages together:

```json
{
    "dashboard": {
        "/overview": {
            "name": "Plugin Overview",
            "icon": "ğŸ“Š",
            "component": "overview.html",
            "redirect": "/overview",
            "description": "View plugin overview",
            "category": "dashboard",
            "showBadge": false
        }
    },
    "client": {
        "/client-dashboard": {
            "name": "Client Dashboard",
            "icon": "ğŸ¯",
            "component": "client-dashboard.html",
            "redirect": "/client-dashboard",
            "description": "Client-specific features",
            "category": "client",
            "showBadge": false
        }
    },
    "admin": {
        "/settings": {
            "name": "Plugin Settings",
            "icon": "âš™ï¸",
            "component": "settings.html",
            "redirect": "/settings",
            "description": "Configure plugin",
            "category": "admin",
            "permission": "admin.plugin.settings",
            "group": "Plugin Management",
            "showBadge": false
        },
        "/advanced": {
            "name": "Advanced Settings",
            "icon": "ğŸ”§",
            "component": "advanced.html",
            "redirect": "/advanced",
            "description": "Advanced configuration",
            "category": "admin",
            "permission": "admin.plugin.advanced",
            "group": "Plugin Management",
            "showBadge": false
        }
    },
    "server": {
        "/main": {
            "name": "Plugin Manager",
            "icon": "ğŸ”",
            "component": "serverui.html",
            "redirect": "/main",
            "description": "Manage plugin features",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        },
        "/installed": {
            "name": "Installed Items",
            "icon": "ğŸ“¦",
            "component": "installed.html",
            "redirect": "/installed",
            "description": "View installed items",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        }
    }
}
```

In this example:

-   Dashboard and client sections have standalone items
-   Admin section has two items grouped under "Plugin Management"
-   Server section has two items grouped under "Minecraft Java Edition"

### How Plugin Rendered Pages Work

FeatherPanel uses a special `PluginRenderedPage` component that automatically loads and displays your plugin's HTML components via iframes. This component handles routing, context detection, and URL parameter injection automatically.

#### Route Matching

Plugin pages are automatically routed using catch-all routes:

-   **Dashboard/Client**: `/dashboard/{plugin_path}` â†’ Loads from `sidebar.json` `dashboard` or `client` section
-   **Admin**: `/admin/{plugin_path}` â†’ Loads from `sidebar.json` `admin` section
-   **Server**: `/server/{serverUuid}/{plugin_path}` â†’ Loads from `sidebar.json` `server` section

The `PluginRenderedPage` component:

1.  Fetches plugin sidebar configuration from `/api/system/plugin-sidebar`
2.  Determines context (`admin`, `client`, or `server`) from the current route
3.  Matches the current route path to a sidebar item
4.  Loads the component HTML file via iframe from `/components/{plugin}/{component}`
5.  Automatically injects URL parameters (`serverUuid`, `userUuid`)
6.  Handles loading states, errors, and developer mode reload functionality

#### Component Loading Path

Your plugin HTML files are served from:

```
/components/{plugin_identifier}/{component_filename}
```

For example, if your plugin identifier is `my_plugin` and your component is `main-page.html`:

```
/components/my_plugin/main-page.html
```

**File Location:**

The component files must be located in your plugin's `Frontend/Components/` directory:

```
storage/addons/my_plugin/
â””â”€â”€ Frontend/
    â””â”€â”€ Components/
        â”œâ”€â”€ main-page.html      â† Served as /components/my_plugin/main-page.html
        â”œâ”€â”€ settings.html        â† Served as /components/my_plugin/settings.html
        â””â”€â”€ serverui.html       â† Served as /components/my_plugin/serverui.html
```

**Important Notes:**

-   Component files are served statically by FeatherPanel's web server
-   The plugin identifier in the URL matches your plugin's directory name
-   Component filenames are case-sensitive
-   Only files in the `Components/` directory are accessible
-   The component path in `sidebar.json` should be relative to `Components/` (e.g., `"main-page.html"`, not `"Components/main-page.html"`)

#### Automatic URL Parameters

The `PluginRenderedPage` component automatically adds query parameters to your component URL:

**For Server Context:**

```
/components/my_plugin/serverui.html?serverUuid={uuid}&userUuid={uuid}
```

**For Admin/Client Context:**

```
/components/my_plugin/settings.html?userUuid={uuid}
```

These parameters are automatically extracted from cookies and the current route, so your plugin pages always have access to the current user and server context.

#### Accessing Context Information

Plugin pages can access context through URL query parameters that are automatically injected:

-   **Server context**: `?serverUuid={uuid}` - Automatically added for server pages
-   **User context**: `?userUuid={uuid}` - Automatically added for all authenticated pages
-   **Query parameters**: Parse with `URLSearchParams` to get custom parameters

```javascript
// Get server UUID from URL (automatically injected)
function getServerUuidFromUrl() {
    const params = new URLSearchParams(window.location.search);
    return params.get('serverUuid') || null;
}

// Get user UUID from URL (automatically injected)
function getUserUuidFromUrl() {
    const params = new URLSearchParams(window.location.search);
    return params.get('userUuid') || null;
}

// Use in API calls
const serverUuid = getServerUuidFromUrl();
const userUuid = getUserUuidFromUrl();

if (serverUuid) {
    fetch(`/api/user/servers/${serverUuid}/addons/my_plugin/endpoint`)
        .then((response) => response.json())
        .then((data) => {
            // Handle response
        });
}
```

#### Developer Mode Features

When developer mode is enabled, the `PluginRenderedPage` component provides:

-   **Reload Button**: Floating reload button in the bottom-right corner to quickly reload the iframe
-   **Loading Indicators**: Visual feedback during iframe loading
-   **Error Handling**: Clear error messages if the component fails to load

#### Custom Scrollbar Injection

The `PluginRenderedPage` component automatically injects custom scrollbar styles into your plugin pages for consistency with FeatherPanel's design. These styles are injected after the iframe loads and support both light and dark modes.

#### Route Matching Logic

The component uses intelligent route matching:

1.  **Exact Path Match**: First tries to match the exact route path from `sidebar.json`
2.  **Redirect Match**: If not found, matches against the `redirect` property
3.  **Plugin Identifier Match**: Falls back to matching by plugin identifier in the path
4.  **Component Fallback**: If a matching item doesn't have a component, searches for another item with the same plugin that has a component

This ensures your plugin pages are always found, even if routes change or multiple entries exist for the same plugin.

### Page Navigation

Since plugin pages are rendered via `PluginRenderedPage`, navigation works seamlessly with Vue Router. You can navigate between plugin pages using standard browser navigation or programmatically:

#### Browser Navigation

Users can navigate to plugin pages directly via the sidebar or by typing URLs:

-   Dashboard: `/dashboard/{plugin_path}`
-   Admin: `/admin/{plugin_path}`
-   Server: `/server/{serverUuid}/{plugin_path}`

#### Programmatic Navigation

Within your plugin HTML pages, you can navigate using standard browser APIs:

```javascript
// Navigate to another plugin page (same context)
function navigateToPage(pageName) {
    const serverUuid = getServerUuidFromUrl();
    const currentPath = window.location.pathname;

    // Determine base path based on current context
    let basePath;
    if (currentPath.startsWith('/server/')) {
        // Server context: preserve server UUID
        const parts = currentPath.split('/');
        basePath = `/server/${parts[2]}`;
    } else if (currentPath.startsWith('/admin')) {
        basePath = '/admin';
    } else {
        basePath = '/dashboard';
    }

    // Navigate using window.location (full page reload)
    window.location.href = `${basePath}/${pageName}`;
}

// Example: Navigate from main page to settings
navigateToPage('settings');
```

#### Using Vue Router (from Parent Context)

If you need to navigate from JavaScript actions (`js` property), you can access the parent window's Vue Router:

```javascript
// In your plugin's JavaScript action
function navigateToPluginPage(path) {
    // Access parent window's router
    if (window.parent && window.parent.$router) {
        window.parent.$router.push(path);
    } else {
        // Fallback to window.location
        window.location.href = path;
    }
}
```

#### Navigation Best Practices

-   **Use relative paths**: When navigating within the same plugin, use relative paths
-   **Preserve context**: Always preserve the server UUID when navigating in server context
-   **Handle errors**: Check if navigation targets exist before navigating
-   **Update URL**: Use proper URLs that match your `sidebar.json` configuration

### Best Practices for Plugin Pages

#### 1. Design Consistency

-   Use FeatherPanel's design language
-   Match existing UI patterns and colors
-   Ensure responsive design for mobile devices

#### 2. Performance

-   Minimize external dependencies
-   Lazy load heavy resources
-   Optimize images and assets

#### 3. Error Handling

-   Always check for `serverUuid` in server contexts
-   Handle API errors gracefully
-   Provide user-friendly error messages

#### 4. Security

-   Never expose sensitive data in client-side code
-   Validate all user inputs
-   Use proper authentication for API calls

#### 5. Accessibility

-   Use semantic HTML elements
-   Provide ARIA labels where needed
-   Ensure keyboard navigation works
-   Test with screen readers

#### 6. PluginRenderedPage Integration

-   **Transparent Background**: Set `body { background: transparent; }` to blend with FeatherPanel's background
-   **Responsive Design**: Ensure your pages work within the iframe container (full viewport height)
-   **Loading States**: The parent component handles loading indicators, but you can add your own
-   **Error Handling**: Handle API errors gracefully - the parent component will show error overlays for iframe load failures
-   **URL Parameters**: Always check for `serverUuid` and `userUuid` parameters that are automatically injected
-   **Developer Mode**: Test with developer mode enabled to use the reload button for faster iteration

### Complete Example

Here's a complete example of a plugin with multiple pages:

**File Structure:**

```
Frontend/
â”œâ”€â”€ index.js
â”œâ”€â”€ index.css
â”œâ”€â”€ sidebar.json
â””â”€â”€ Components/
    â”œâ”€â”€ serverui.html
    â””â”€â”€ installed.html
```

**sidebar.json:**

```json
{
    "server": {
        "/pluginmanager": {
            "name": "Plugin Manager",
            "icon": "ğŸ”",
            "component": "serverui.html",
            "redirect": "/pluginmanager",
            "description": "Manage plugins",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        },
        "/installed": {
            "name": "Installed Items",
            "icon": "ğŸ“¦",
            "component": "installed.html",
            "redirect": "/installed",
            "description": "View installed items",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        }
    }
}
```

Notice how both items use the same `group` value (`"Minecraft Java Edition"`), which will display them together under a group header in the sidebar.

**Components/serverui.html:**

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Plugin Manager</title>
        <!-- Add your styles and scripts -->
    </head>
    <body>
        <!-- Page content -->
        <script>
            // Initialize page
        </script>
    </body>
</html>
```

This approach allows plugins to create rich, interactive interfaces that integrate seamlessly with FeatherPanel's navigation system.

### Using Vite and Modern Frameworks

For complex plugin pages, you can use Vite to build Vue, React, or other modern framework applications. This enables:

-   **Component-based architecture** with Vue or React
-   **Modern build tools** (TypeScript, TailwindCSS, etc.)
-   **Hot Module Replacement** during development
-   **Code splitting** and optimization
-   **Full framework ecosystem** (Vue Router, React Router, etc.)

#### Vite Configuration Requirements

When using Vite for plugin pages, you **must** configure it with these specific settings:

**`vite.config.ts` (Vue Example):**

```typescript
import path from 'node:path';
import tailwindcss from '@tailwindcss/vite';
import vue from '@vitejs/plugin-vue';
import { defineConfig } from 'vite';

export default defineConfig({
    plugins: [vue(), tailwindcss()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'),
        },
    },
    // CRITICAL: Use relative base path
    base: './',
    build: {
        // CRITICAL: Build output must be in Components/{name}/dist/
        outDir: '../Components/myplugin/dist/',
        emptyOutDir: true,
    },
});
```

**Key Configuration Points:**

1.  **`base: './'`** - **Required**: Uses relative paths so assets load correctly when served from `/components/{plugin}/{component}`
2.  **`build.outDir`** - **Required**: Must point to `../Components/{component_name}/dist/` relative to your Vite config file
3.  **`emptyOutDir: true`** - Recommended: Cleans the output directory before each build

#### Router Configuration (Vue Router)

When using Vue Router in plugin pages, you **must** use `createWebHashHistory()` instead of `createWebHistory()`:

```typescript
import { createRouter, createWebHashHistory } from 'vue-router';
import type { RouteRecordRaw } from 'vue-router';

const routes: RouteRecordRaw[] = [
    {
        path: '/',
        name: 'Home',
        component: () => import('@/pages/Home.vue'),
    },
    {
        path: '/settings',
        name: 'Settings',
        component: () => import('@/pages/Settings.vue'),
    },
];

// CRITICAL: Use createWebHashHistory, not createWebHistory
const router = createRouter({
    history: createWebHashHistory(),
    routes,
});

export default router;
```

**Why Hash History?**

-   Plugin pages are loaded via iframe from `/components/{plugin}/{component}`
-   Hash-based routing (`#/path`) works correctly within iframes
-   Browser history routing would conflict with FeatherPanel's main router

#### React Router Configuration

For React applications, use hash-based routing:

```typescript
import { createHashRouter } from 'react-router-dom';

const router = createHashRouter([
    {
        path: '/',
        element: <Home />,
    },
    {
        path: '/settings',
        element: <Settings />,
    },
]);
```

#### Sidebar Configuration for Built Components

When using Vite-built applications, reference the built `index.html` file:

```json
{
    "server": {
        "/myplugin": {
            "name": "My Plugin",
            "icon": "ğŸ”§",
            "component": "/myplugin/dist/index.html",
            "redirect": "/myplugin",
            "description": "Access My Plugin",
            "category": "server",
            "group": "Minecraft Java Edition",
            "showBadge": false
        }
    }
}
```

**Component Path Format:**

-   Path: `/myplugin/dist/index.html`
-   Resolves to: `Components/myplugin/dist/index.html`
-   The path is relative to the `Components/` directory

#### Project Structure Example

```
storage/addons/my_plugin/
â”œâ”€â”€ Frontend/
â”‚   â”œâ”€â”€ sidebar.json
â”‚   â””â”€â”€ App/                    # Vite project directory
â”‚       â”œâ”€â”€ vite.config.ts      # Vite configuration
â”‚       â”œâ”€â”€ package.json
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ main.ts         # Entry point
â”‚       â”‚   â”œâ”€â”€ App.vue
â”‚       â”‚   â”œâ”€â”€ router/
â”‚       â”‚   â”‚   â””â”€â”€ index.ts    # Router with hash history
â”‚       â”‚   â””â”€â”€ pages/
â”‚       â”‚       â”œâ”€â”€ Home.vue
â”‚       â”‚       â””â”€â”€ Settings.vue
â”‚       â””â”€â”€ Components/         # Build output goes here
â”‚           â””â”€â”€ myplugin/
â”‚               â””â”€â”€ dist/       # Built files
â”‚                   â”œâ”€â”€ index.html
â”‚                   â”œâ”€â”€ assets/
â”‚                   â””â”€â”€ ...
```

#### Development Workflow

1.  **Development**: Run `pnpm dev` or `npm run dev` in your `App/` directory
2.  **Build**: Run `pnpm build` or `npm run build` to compile to `Components/{name}/dist/`
3.  **Test**: Navigate to your plugin page in FeatherPanel to test the built version
4.  **Iterate**: Rebuild after making changes

#### Accessing URL Parameters

Vite-built applications can access URL parameters the same way as static HTML:

```typescript
// Vue example
import { useRoute } from 'vue-router';

export default {
    setup() {
        const route = useRoute();
        const serverUuid = route.query.serverUuid as string;
        const userUuid = route.query.userUuid as string;

        // Use parameters in API calls
        fetch(`/api/user/servers/${serverUuid}/addons/my_plugin/data`)
            .then((response) => response.json())
            .then((data) => {
                // Handle data
            });
    },
};
```

```typescript
// React example
import { useSearchParams } from 'react-router-dom';

function MyComponent() {
    const [searchParams] = useSearchParams();
    const serverUuid = searchParams.get('serverUuid');
    const userUuid = searchParams.get('userUuid');

    // Use parameters in API calls
    useEffect(() => {
        if (serverUuid) {
            fetch(`/api/user/servers/${serverUuid}/addons/my_plugin/data`)
                .then((response) => response.json())
                .then((data) => {
                    // Handle data
                });
        }
    }, [serverUuid]);
}
```

#### Complete Vite + Vue Example

**`vite.config.ts`:**

```typescript
import path from 'node:path';
import tailwindcss from '@tailwindcss/vite';
import vue from '@vitejs/plugin-vue';
import { defineConfig } from 'vite';

export default defineConfig({
    plugins: [vue(), tailwindcss()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src'),
        },
    },
    base: './',
    build: {
        outDir: '../Components/myplugin/dist/',
        emptyOutDir: true,
    },
});
```

**`src/router/index.ts`:**

```typescript
import { createRouter, createWebHashHistory } from 'vue-router';
import type { RouteRecordRaw } from 'vue-router';

const routes: RouteRecordRaw[] = [
    {
        path: '/',
        name: 'Home',
        component: () => import('@/pages/Home.vue'),
    },
];

const router = createRouter({
    history: createWebHashHistory(),
    routes,
});

export default router;
```

**`sidebar.json`:**

```json
{
    "server": {
        "/myplugin": {
            "name": "My Plugin",
            "icon": "ğŸ”§",
            "component": "/myplugin/dist/index.html",
            "redirect": "/myplugin",
            "description": "My Vite-built plugin",
            "category": "server",
            "showBadge": false
        }
    }
}
```

#### Benefits of Vite-Built Plugin Pages

-   **Modern Development**: Use TypeScript, modern JavaScript, and framework features
-   **Component Libraries**: Integrate shadcn-vue, reka-ui, or other component libraries
-   **Build Optimization**: Automatic code splitting, tree shaking, and minification
-   **Hot Reload**: Fast development with HMR during development
-   **Type Safety**: Full TypeScript support for better development experience
-   **Ecosystem**: Access to entire Vue/React ecosystem (routers, state management, etc.)

#### Limitations and Considerations

-   **Build Step Required**: Must rebuild after changes (no live editing)
-   **File Size**: Built applications are larger than simple HTML pages
-   **Hash Routing**: Must use hash-based routing (works well but different from standard routing)
-   **Iframe Context**: Runs in iframe, so some browser APIs may behave differently
-   **Base Path**: Must use relative paths (`base: './'`) for assets to load correctly

> **Related:** For embedding content into existing FeatherPanel pages, see [Plugin Widgets](./plugins-widgets) - which allow you to inject custom HTML at specific locations on dashboard, server, and admin pages.

## Development Best Practices

### Code Organization

-   Use proper namespacing
-   Separate concerns (controllers, services, models)
-   Use dependency injection
-   Follow PSR standards

### Error Handling

-   Use try-catch blocks
-   Log errors appropriately
-   Provide meaningful error messages
-   Handle edge cases

### Performance

-   Cache expensive operations
-   Use database indexes
-   Minimize database queries
-   Optimize file operations

### Security

-   Validate all inputs
-   Use prepared statements
-   Check permissions
-   Sanitize outputs

### Testing

-   Write unit tests
-   Test edge cases
-   Validate configurations
-   Test error conditions

## Deployment

### Packaging Your Plugin

1. Ensure all files are present
2. Test the plugin thoroughly
3. Create a README with installation instructions
4. Package as `.fpa` file using the export feature

### Distribution

-   Upload to the FeatherPanel packages registry
-   Provide documentation and examples
-   Include version information
-   Test installation process

This development workflow provides a solid foundation for creating robust, maintainable FeatherPanel plugins.
